线程：
并行：同一时间点内执行多项任务
-----------------------------------
并发：高速的在多项任务中切换执行，几乎是同一时间，但准确的说并不是同一时间
1、
同一时间，有多条执行路径
-----------------------------------
2、进程和线程
进程是每个独立程序在系统中的一次执行活动，比如QQ ，360
进程又可以进一步分为线程，线程是程序内部的一条执行路径
-----------------------------------
3、为什么要使用多线程
1.提高CPU使用率
2.将比较耗时的操作放在后台执行，以免阻塞主线程
3。提高程序的响应
-----------------------------------
4、线程的创建有2中方式
1.继承Thread类
2.实现Runnable接口
-----------------------------------
5、构造方法：
public		Thread()		
public 		Thread(Runn	able rb)	//需要实现这个接口的子类，并且重写该run方法
-----------------------------------
5、线程汇总的几个方法
1.start()		//启动线程，同一个线程对象只能启动一次！
2.run()			//调用线程执行体，但手动调用不会使用多线程执行，只有通过start调用才使用多线程
3.Thread.currentThread()	//返回一个线程，哪个线程调用就返回哪个。
4.Thread.sleep(int Time)	//让某个线程停止一段时间，会抛异常
5.getPriority()			//获取线程优先级
6.setPriority(静态值)		//设置线程优先级
	Thread.MAX_PRIORITY = 10	//最大优先级
	Thread.MIN_PRIORITY = 1;	//最小优先级
	Thread.NORM_PRIORITY = 5; 	//默认优先级
可以设置线程优先级，优先级越高更容易先执行
7.setName("");				//设置线程名字
8. boolean 	isAlive()		//测试线程是否活着
9.Thread.yield()		//暂时停止线程，让当前回到就绪状态，让其他线程运行，但它也可能随时运行
10.void		join()		//强行将次线程插入到当前线程。很黄很暴力
-----------------------------------
6、线程的5个状态：
新建状态、就绪状态、运行状态、阻塞状态、死亡(执行完毕)
-----------------------------------

synchronized		//同步锁，限制只能由一根线程访问。跟在访问修饰符后面

synchronized(this){}	//同步代码块，存在方法中。this表示获取当前对象的同步锁，填别的对象就是别的对象锁，跟当前对象锁不冲突。	


PS：当一跟线程访问该对象的同步方法时候，其他线程不能访问该对象的所有同步方法。但是可以访问该对象的不同步方法